
directive lean
import Batteries.Data.Rat
import Soda.tiles.fairness.tool.TileMessage

directive lean
notation "Number" => Rat

directive scala
type Number = Double

directive lean
def as_Number (x : Number) : Number := x

directive scala
def as_Number (x : Int) : Number = x

/**
 * This class contains helper functions for mathematical calculations.
 */

class MathTool

  abstract

  _tailrec_foldl [A : Type] [B : Type] (sequence : Seq [A] ) (current : B)
      (next : B -> A -> B) : B =
    match sequence
      case Nil ==> current
      case (head) +: (tail) ==>
        _tailrec_foldl [A] [B] (tail) (next (current) (head) ) (next)

  squared (x : Number) : Number =
    x * x

  _sum_init : Number = 0

  _sum_next (accum : Number) (elem : Number) : Number =
    accum + elem

  sum (seq : Seq [Number] ) : Number =
    _tailrec_foldl [Number] [Number] (seq) (_sum_init) (_sum_next)

  average (seq : Seq [Number] ) : Number =
    sum (seq) / as_Number (seq .length)

end


/**
 * The main function in this class computes the Pearson correlation coefficient.
 *
 *  r_{x,y} =\frac{\sum _{i=1}^{n}(x_{i} - \bar{x})(y_{i} -
 *  \bar{y})}{\sqrt{\sum _{i=1}^{n}(x_{i} - \bar{x})^2} \sqrt{\sum ^{n} _{i=1}(y_{i} -
 *  \bar{y})^{2}}}
 */

class Pearson

  abstract
    xlist : Seq [Number]
    ylist : Seq [Number]

  _mm : MathTool = MathTool .mk

  directive lean
  notation "Math.sqrt" => MathTool.sqrt
  notation "_mm.average" => MathTool.average
  notation "_mm.sum" => MathTool.sum
  notation "_mm.squared" => MathTool.squared

  _sum_squared_diff_with (seq : Seq [Number] ) (x_average : Number) : Number =
    _mm .sum (seq .map (lambda x_i --> _mm .squared (x_i - x_average) ) )

  sum_squared_diff (seq : Seq [Number] ) : Number =
    _sum_squared_diff_with (seq) (_mm .average (seq) )

  _sqrt_sum_squared_diff (seq : Seq [Number] ) : Number =
    Math.sqrt (sum_squared_diff (seq) )

  _denominator : Number =
    _sqrt_sum_squared_diff (xlist) * _sqrt_sum_squared_diff (ylist)

  _multip (x_i : Number) (y_i : Number) (x_average : Number) (y_average : Number) : Number =
    (x_i - x_average) * (y_i - y_average)

  _numerator_with (pair_list : Seq [Tuple2 [Number] [Number] ] ) (x_average : Number)
      (y_average : Number) : Number =
    _mm .sum (pair_list .map (lambda pair -->
      _multip (pair ._1) (pair ._2) (x_average) (y_average) ) )

  _x_y_together : Seq [Tuple2 [Number] [Number] ] =
    xlist .zip (ylist)

  _numerator : Number =
    _numerator_with (_x_y_together) (_mm .average (xlist) ) (_mm .average (ylist) )

  coefficient : Number =
    _numerator / _denominator

end


class ScoringCategory

  abstract

  undefined_correlation : Int = 0

  no_correlation : Int = 1

  weak_positive_correlation : Int = 2

  weak_negative_correlation : Int = 3

  moderate_positive_correlation : Int = 4

  moderate_negative_correlation : Int = 5

  strong_positive_correlation : Int = 6

  strong_negative_correlation : Int = 7

  categorize (x : Number) : Int =
    if (x > 0.5) and (x <= 1.0) then strong_positive_correlation
    else if (x > 0.3) and (x <= 0.5) then moderate_positive_correlation
    else if (x > 0) and (x <= 0.3) then weak_positive_correlation
    else if (x == 0) then no_correlation
    else if (x < 0) and (x >= -0.3) then weak_negative_correlation
    else if (x < -0.3) and (x >= -0.5) then moderate_negative_correlation
    else if (x < -0.5) and (x >= -1.0) then strong_negative_correlation
    else undefined_correlation

end

