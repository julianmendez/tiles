
directive lean
import Soda.tiles.fairness.tool.TileMessage
import Batteries.Lean.Float

directive lean
notation "Number" => Float
def as_number (x : Int) : Number := Int.divFloat (x) (1)
def as_pair (x : Prod (Number) (Number) ) : TilePair (Number) (Number) := TilePair.mk (x.fst) (x.snd)

directive scala
type Number = Double
def as_number (x : Int) : Number = x.toDouble
def as_pair (x : Tuple2 [Number, Number] ) : TilePair [Number, Number] = TilePair.mk [Number, Number] (x._1) (x._2)

/**
 * This class contains helper functions for mathematical calculations.
 */

class MathTool

  abstract

  _tailrec_foldl [A : Type] [B : Type] (sequence : Seq [A] ) (current : B)
      (next : B -> A -> B) : B =
    match sequence
      case Nil ==> current
      case (head) +: (tail) ==>
        _tailrec_foldl [A] [B] (tail) (next (current) (head) ) (next)

  squared (x : Number) : Number =
    x * x

  sqrt (x : Number) : Number =
    Math .sqrt (x)

  _sum_init : Number = 0

  _sum_next (accum : Number) (elem : Number) : Number =
    accum + elem

  sum (seq : Seq [Number] ) : Number =
    _tailrec_foldl [Number] [Number] (seq) (_sum_init) (_sum_next)

  average (seq : Seq [Number] ) : Number =
    sum (seq) / as_number (seq .length)

  abs (x : Number) : Number =
    if x < 0
    then (-1) * x
    else x

  is_within (maybeNumber : Option [Number] ) (center : Double) (epsilon : Double) : Boolean =
    maybeNumber
      .exists (lambda value -->
        abs (value - center) <= epsilon)

  min (x : Number) (y : Number) : Number =
    if x < y
    then x
    else y

  max (x : Number) (y : Number) : Number =
    if x > y
    then x
    else y

end


class SeqPair

  abstract
    xlist : Seq [Number]
    ylist : Seq [Number]

end


/**
 * The main function in this class computes the Pearson correlation coefficient.
 * It uses a direct formula.
 *
 *  r_{x,y} = \frac{\sum _{i=1}^{n}(x_{i} - \bar{x})(y_{i} -
 *  \bar{y})}{\sqrt{\sum _{i=1}^{n}(x_{i} - \bar{x})^2} \sqrt{\sum ^{n} _{i=1}(y_{i} -
 *  \bar{y})^{2}}}
 */

class PearsonCorrDirect

  abstract

  _mm : MathTool = MathTool .mk

  directive lean
  notation "_mm.sqrt" => Float.sqrt
  notation "_mm.average" => MathTool.average
  notation "_mm.sum" => MathTool.sum
  notation "_mm.squared" => MathTool.squared

  _sum_squared_diff_with (seq : Seq [Number] ) (x_average : Number) : Number =
    _mm .sum (seq .map (lambda x_i --> _mm .squared (x_i - x_average) ) )

  sum_squared_diff (seq : Seq [Number] ) : Number =
    _sum_squared_diff_with (seq) (_mm .average (seq) )

  _sqrt_sum_squared_diff (seq : Seq [Number] ) : Number =
    _mm .sqrt (sum_squared_diff (seq) )

  _denominator (m : SeqPair) : Number =
    _sqrt_sum_squared_diff (m .xlist) * _sqrt_sum_squared_diff (m .ylist)

  _multip (x_i : Number) (y_i : Number) (x_average : Number) (y_average : Number) : Number =
    (x_i - x_average) * (y_i - y_average)

  _numerator_with (pair_list : Seq [TilePair [Number] [Number] ] ) (x_average : Number)
      (y_average : Number) : Number =
    _mm .sum (pair_list .map (lambda pair -->
      _multip (pair .fst) (pair .snd) (x_average) (y_average) ) )

  _x_y_together (m : SeqPair) : Seq [TilePair [Number] [Number] ] =
    (m .xlist .zip (m .ylist) ) .map (lambda elem --> as_pair (elem) )

  _numerator (m : SeqPair) : Number =
    _numerator_with (_x_y_together (m) ) (_mm .average (m .xlist) ) (_mm .average (m .ylist) )

  coefficient_with (numerator : Number) (denominator : Number) : Option [Number] =
    if denominator == 0
    then None
    else Some (numerator / denominator)

  coefficient (m : SeqPair) : Option [Number] =
    coefficient_with (_numerator (m) ) (_denominator (m) )

end


/**
 * The main function in this class computes the Pearson correlation coefficient.
 * It computes the sample covariance and the sample standard deviation.
 *
 * r_{X,Y} = \frac{\mathrm{Cov}(X, Y)}{\sigma_{X} \, \sigma_{Y}}
 */

class PearsonCorrCovariance

  abstract

  _mm : MathTool = MathTool .mk

  _covariance_with (xs : Seq [Number] ) (ys : Seq [Number] ) (mu_x : Number) (mu_y : Number) (n : Number)
      : Option [Number] =
    if n > 1
    then Some (
      _mm .sum (
        xs
          .zip (ys)
          .map (lambda pair --> (pair ._1 - mu_x) * (pair ._2 - mu_y) )
      ) / (n - 1)
    )
    else None

  /** Sample covariance: Cov(X,Y) = Σ (xᵢ - μₓ)(yᵢ - μᵧ) / (n - 1) */

  covariance (xs : Seq [Number] ) (ys : Seq [Number] ) : Option [Number] =
    _covariance_with (xs) (ys) (_mm .average (xs) ) (_mm .average (ys) ) (as_number (xs .length) )

  /** Sample variance: Var(X) = Cov(X, X) */

  variance (seq : Seq [Number] ) : Option [Number] =
    covariance (seq) (seq)

  /** Sample standard deviation: σₓ = sqrt(Var(X)) */

  stddev (seq : Seq [Number] ) : Option [Number] =
    variance (seq)
      .map (lambda v --> _mm .sqrt (v) )

  coefficient_with (cov_xy : Option [Number] ) (stddev_x : Option [Number] ) (stddev_y : Option [Number] )
      : Option [Number] =
    stddev_x
      .filter (lambda x --> not (x == 0) )
      .flatMap (lambda stddev_x_val -->
        stddev_y
          .filter (lambda x --> not (x == 0) )
          .flatMap (lambda stddev_y_val -->
            cov_xy .map (lambda cov_xy_val -->
              cov_xy_val / (stddev_x_val * stddev_y_val)
            )
          )
      )

  /** Pearson correlation coefficient: r = Cov(X,Y) / (σₓ * σᵧ) */

  coefficient (m : SeqPair) : Option [Number] =
    coefficient_with (
      covariance (m .xlist) (m .ylist)
    ) (
      stddev (m .xlist)
    ) (
      stddev (m .ylist)
    )

end


class ScoringCategory

  abstract

  undefined_correlation : Int = 0

  no_correlation : Int = 1

  weak_positive_correlation : Int = 2

  weak_negative_correlation : Int = 3

  moderate_positive_correlation : Int = 4

  moderate_negative_correlation : Int = 5

  strong_positive_correlation : Int = 6

  strong_negative_correlation : Int = 7

  categorize (x : Number) : Int =
    if (x > 0.5) and (x <= 1.0) then strong_positive_correlation
    else if (x > 0.3) and (x <= 0.5) then moderate_positive_correlation
    else if (x > 0) and (x <= 0.3) then weak_positive_correlation
    else if (x == 0) then no_correlation
    else if (x < 0) and (x >= -0.3) then weak_negative_correlation
    else if (x < -0.3) and (x >= -0.5) then moderate_negative_correlation
    else if (x < -0.5) and (x >= -1.0) then strong_negative_correlation
    else undefined_correlation

end

